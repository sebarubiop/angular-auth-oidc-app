import { Injectable } from '@angular/core';
// const sha256 = factory();
import fsha256 from './fast-sha256js';
import * as i0 from "@angular/core";
/**
 * Abstraction for crypto algorithms
 */
export class HashHandler {
}
function decodeUTF8(s) {
    if (typeof s !== 'string')
        throw new TypeError('expected string');
    const d = s, b = new Uint8Array(d.length);
    for (let i = 0; i < d.length; i++)
        b[i] = d.charCodeAt(i);
    return b;
}
function encodeUTF8(arr) {
    const s = [];
    for (let i = 0; i < arr.length; i++)
        s.push(String.fromCharCode(arr[i]));
    return s.join('');
}
class DefaultHashHandler {
    async calcHash(valueToHash, algorithm) {
        // const encoder = new TextEncoder();
        // const hashArray = await window.crypto.subtle.digest(algorithm, data);
        // const data = encoder.encode(valueToHash);
        // const fhash = fsha256(valueToHash);
        const candHash = encodeUTF8(fsha256(decodeUTF8(valueToHash)));
        // const hashArray = (sha256 as any).array(valueToHash);
        // // const hashString = this.toHashString(hashArray);
        // const hashString = this.toHashString2(hashArray);
        // console.debug('hash orig - cand', candHash, hashString);
        // alert(1);
        return candHash;
    }
    toHashString2(byteArray) {
        let result = '';
        for (const e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
    toHashString(buffer) {
        const byteArray = new Uint8Array(buffer);
        let result = '';
        for (const e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DefaultHashHandler, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DefaultHashHandler }); }
}
export { DefaultHashHandler };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.3", ngImport: i0, type: DefaultHashHandler, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbGliL3NyYy90b2tlbi12YWxpZGF0aW9uL2hhc2gtaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLDRCQUE0QjtBQUU1QixPQUFPLE9BQU8sTUFBTSxpQkFBaUIsQ0FBQzs7QUFFdEM7O0dBRUc7QUFDSCxNQUFNLE9BQWdCLFdBQVc7Q0FFaEM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxDQUFDO0lBQ25CLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUTtRQUFFLE1BQU0sSUFBSSxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNsRSxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQ1QsQ0FBQyxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUU7UUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxHQUFHO0lBQ3JCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNiLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRTtRQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNwQixDQUFDO0FBRUQsTUFDYSxrQkFBa0I7SUFDN0IsS0FBSyxDQUFDLFFBQVEsQ0FBQyxXQUFtQixFQUFFLFNBQWlCO1FBQ25ELHFDQUFxQztRQUNyQyx3RUFBd0U7UUFDeEUsNENBQTRDO1FBRTVDLHNDQUFzQztRQUV0QyxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUQsd0RBQXdEO1FBQ3hELHNEQUFzRDtRQUN0RCxvREFBb0Q7UUFFcEQsMkRBQTJEO1FBQzNELFlBQVk7UUFFWixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQsYUFBYSxDQUFDLFNBQW1CO1FBQy9CLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztRQUNoQixLQUFLLE1BQU0sQ0FBQyxJQUFJLFNBQVMsRUFBRTtZQUN6QixNQUFNLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxZQUFZLENBQUMsTUFBbUI7UUFDOUIsTUFBTSxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekMsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLEtBQUssTUFBTSxDQUFDLElBQUksU0FBUyxFQUFFO1lBQ3pCLE1BQU0sSUFBSSxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2xDO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs4R0FuQ1Usa0JBQWtCO2tIQUFsQixrQkFBa0I7O1NBQWxCLGtCQUFrQjsyRkFBbEIsa0JBQWtCO2tCQUQ5QixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBmYWN0b3J5IH0gZnJvbSAnLi9qcy1zaGEyNTYnO1xuLy8gY29uc3Qgc2hhMjU2ID0gZmFjdG9yeSgpO1xuXG5pbXBvcnQgZnNoYTI1NiBmcm9tICcuL2Zhc3Qtc2hhMjU2anMnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBjcnlwdG8gYWxnb3JpdGhtc1xuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFzaEhhbmRsZXIge1xuICBhYnN0cmFjdCBjYWxjSGFzaCh2YWx1ZVRvSGFzaDogc3RyaW5nLCBhbGdvcml0aG06IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVVRGOChzKSB7XG4gIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHN0cmluZycpO1xuICBjb25zdCBkID0gcyxcbiAgICBiID0gbmV3IFVpbnQ4QXJyYXkoZC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGQubGVuZ3RoOyBpKyspIGJbaV0gPSBkLmNoYXJDb2RlQXQoaSk7XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVVVEY4KGFycikge1xuICBjb25zdCBzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhcnJbaV0pKTtcbiAgcmV0dXJuIHMuam9pbignJyk7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEZWZhdWx0SGFzaEhhbmRsZXIgaW1wbGVtZW50cyBIYXNoSGFuZGxlciB7XG4gIGFzeW5jIGNhbGNIYXNoKHZhbHVlVG9IYXNoOiBzdHJpbmcsIGFsZ29yaXRobTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgLy8gY29uc3QgaGFzaEFycmF5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgLy8gY29uc3QgZGF0YSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlVG9IYXNoKTtcblxuICAgIC8vIGNvbnN0IGZoYXNoID0gZnNoYTI1Nih2YWx1ZVRvSGFzaCk7XG5cbiAgICBjb25zdCBjYW5kSGFzaCA9IGVuY29kZVVURjgoZnNoYTI1NihkZWNvZGVVVEY4KHZhbHVlVG9IYXNoKSkpO1xuXG4gICAgLy8gY29uc3QgaGFzaEFycmF5ID0gKHNoYTI1NiBhcyBhbnkpLmFycmF5KHZhbHVlVG9IYXNoKTtcbiAgICAvLyAvLyBjb25zdCBoYXNoU3RyaW5nID0gdGhpcy50b0hhc2hTdHJpbmcoaGFzaEFycmF5KTtcbiAgICAvLyBjb25zdCBoYXNoU3RyaW5nID0gdGhpcy50b0hhc2hTdHJpbmcyKGhhc2hBcnJheSk7XG5cbiAgICAvLyBjb25zb2xlLmRlYnVnKCdoYXNoIG9yaWcgLSBjYW5kJywgY2FuZEhhc2gsIGhhc2hTdHJpbmcpO1xuICAgIC8vIGFsZXJ0KDEpO1xuXG4gICAgcmV0dXJuIGNhbmRIYXNoO1xuICB9XG5cbiAgdG9IYXNoU3RyaW5nMihieXRlQXJyYXk6IG51bWJlcltdKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGZvciAoY29uc3QgZSBvZiBieXRlQXJyYXkpIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdG9IYXNoU3RyaW5nKGJ1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGNvbnN0IGUgb2YgYnl0ZUFycmF5KSB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhleFN0cmluZyhidWZmZXIpIHtcbiAgLy8gICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gIC8vICAgICBjb25zdCBoZXhDb2RlcyA9IFsuLi5ieXRlQXJyYXldLm1hcCh2YWx1ZSA9PiB7XG4gIC8vICAgICAgIGNvbnN0IGhleENvZGUgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gIC8vICAgICAgIGNvbnN0IHBhZGRlZEhleENvZGUgPSBoZXhDb2RlLnBhZFN0YXJ0KDIsICcwJyk7XG4gIC8vICAgICAgIHJldHVybiBwYWRkZWRIZXhDb2RlO1xuICAvLyAgICAgfSk7XG5cbiAgLy8gICAgIHJldHVybiBoZXhDb2Rlcy5qb2luKCcnKTtcbiAgLy8gICB9XG5cbiAgLy8gdG9IYXNoU3RyaW5nKGhleFN0cmluZzogc3RyaW5nKSB7XG4gIC8vICAgbGV0IHJlc3VsdCA9ICcnO1xuICAvLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4U3RyaW5nLmxlbmd0aDsgaSArPSAyKSB7XG4gIC8vICAgICBsZXQgaGV4RGlnaXQgPSBoZXhTdHJpbmcuY2hhckF0KGkpICsgaGV4U3RyaW5nLmNoYXJBdChpICsgMSk7XG4gIC8vICAgICBsZXQgbnVtID0gcGFyc2VJbnQoaGV4RGlnaXQsIDE2KTtcbiAgLy8gICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG51bSk7XG4gIC8vICAgfVxuICAvLyAgIHJldHVybiByZXN1bHQ7XG4gIC8vIH1cbn1cbiJdfQ==